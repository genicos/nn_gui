var app=function(){"use strict";function t(){}function e(t){return t()}function n(){return Object.create(null)}function s(t){t.forEach(e)}function o(t){return"function"==typeof t}function r(t,e){return t!=t?e==e:t!==e||t&&"object"==typeof t||"function"==typeof t}function i(t,e){t.appendChild(e)}function u(t){t.parentNode.removeChild(t)}function a(t){return document.createElement(t)}function l(t){return document.createTextNode(t)}function p(){return l(" ")}function h(t,e,n){null==n?t.removeAttribute(e):t.getAttribute(e)!==n&&t.setAttribute(e,n)}let c;function f(t){c=t}function d(t){(function(){if(!c)throw new Error("Function called outside component initialization");return c})().$$.on_mount.push(t)}const g=[],_=[],m=[],y=[],v=Promise.resolve();let x=!1;function w(t){m.push(t)}const b=new Set;let $=0;function k(){const t=c;do{for(;$<g.length;){const t=g[$];$++,f(t),T(t.$$)}for(f(null),g.length=0,$=0;_.length;)_.pop()();for(let t=0;t<m.length;t+=1){const e=m[t];b.has(e)||(b.add(e),e())}m.length=0}while(g.length);for(;y.length;)y.pop()();x=!1,b.clear(),f(t)}function T(t){if(null!==t.fragment){t.update(),s(t.before_update);const e=t.dirty;t.dirty=[-1],t.fragment&&t.fragment.p(t.ctx,e),t.after_update.forEach(w)}}const L=new Set;function E(t,e){-1===t.$$.dirty[0]&&(g.push(t),x||(x=!0,v.then(k)),t.$$.dirty.fill(0)),t.$$.dirty[e/31|0]|=1<<e%31}function C(r,i,a,l,p,h,d,g=[-1]){const _=c;f(r);const m=r.$$={fragment:null,ctx:null,props:h,update:t,not_equal:p,bound:n(),on_mount:[],on_destroy:[],on_disconnect:[],before_update:[],after_update:[],context:new Map(i.context||(_?_.$$.context:[])),callbacks:n(),dirty:g,skip_bound:!1,root:i.target||_.$$.root};d&&d(m.root);let y=!1;if(m.ctx=a?a(r,i.props||{},((t,e,...n)=>{const s=n.length?n[0]:e;return m.ctx&&p(m.ctx[t],m.ctx[t]=s)&&(!m.skip_bound&&m.bound[t]&&m.bound[t](s),y&&E(r,t)),e})):[],m.update(),y=!0,s(m.before_update),m.fragment=!!l&&l(m.ctx),i.target){if(i.hydrate){const t=function(t){return Array.from(t.childNodes)}(i.target);m.fragment&&m.fragment.l(t),t.forEach(u)}else m.fragment&&m.fragment.c();i.intro&&((v=r.$$.fragment)&&v.i&&(L.delete(v),v.i(x))),function(t,n,r,i){const{fragment:u,on_mount:a,on_destroy:l,after_update:p}=t.$$;u&&u.m(n,r),i||w((()=>{const n=a.map(e).filter(o);l?l.push(...n):s(n),t.$$.on_mount=[]})),p.forEach(w)}(r,i.target,i.anchor,i.customElement),k()}var v,x;f(_)}class M{constructor(t,e){this.scalar=!1,this.live=t||!1,e?this.form=e:e=[],this.x=0,this.y=0,this.input_to=[],this.output_of=null}calc_size(){if(this.form){var t=1;for(let e=0;e<this.form.length;e++)t*=this.form[e];this.size=t}else this.size=0;return this.size}}class P{constructor(t){this.inputs=[],this.outputs=[],this.func=t,this.size=null,this.network=null}clone(){var t=new P(this.func);return t.inputs=[...this.inputs],t.outputs=[...this.outputs],t.network=this.network,t}}class R{constructor(t,e){this.name=t,this.num_inputs=e}calc_form(t,e){var n=[];switch(console.log(this.name),this.name){case"identity":case"add":case"subtract":case"scale":case"softmax":case"hardmax":case"ReLU":case"LeakyReLU":case"Leaky to ReLU":n.push(e.tensors[t[0]].form);break;case"full":var s=e.tensors[t[0]].form,o=e.tensors[t[1]].form,r=1;for(let t=0;t<s.length;t++)r*=s[t];var i=1;for(let t=0;t<o.length;t++)i*=o[t];(u=[]).push(i/r),n.push(u);break;case"amass":case"max":(u=[]).push(1),n.push(u);break;case"convolution":s=e.tensors[t[0]].form,o=e.tensors[t[1]].form;var u=[];for(let t=0;t<s.length;t++)o.length<=t?u.push(s[t]):u.push(s[t]-o[t]+1);n.push(u);break;case"squared dist":n.push([1])}return n}}var S=Array.apply(null,Array(12)).map((function(){}));S[0]=new R("abstraction",0),S[1]=new R("identity",1),S[2]=new R("add",2),S[3]=new R("subtract",2),S[4]=new R("scale",2),S[5]=new R("full",2),S[6]=new R("amass",1),S[7]=new R("softmax",1),S[8]=new R("hardmax",1),S[9]=new R("max",1),S[10]=new R("convolution",2),S[11]=new R("squared dist",2),S[12]=new R("ReLU",1),S[13]=new R("LeakyReLU",1),S[14]=new R("Leaky to ReLU",1);const A=10;function O(t,e,n,s){t.tensors[e].x+=n,t.tensors[e].y+=s}function B(t,e,n){var s=[];for(let o=0;o<t.tensors.length;o++)t.tensors[o].x-A<e&&t.tensors[o].x+A>e&&t.tensors[o].y-A<n&&t.tensors[o].y+A>n&&s.push(o);return s}function U(t,e){var n=t.tensors[e],s=n.input_to;n.input_to=[];for(let a=0;a<s.length;a++){var o=s[a],r=t.operators[o],i=t.tensors.length;t.add_tensor(new M(!0));var u=r.inputs.findIndex((t=>t==e));r.inputs[u]=i,t.tensors[i].x=n.x+20,t.tensors[i].y=n.y,t.tensors[i].input_to=[o],t.tensors[i].output_of=null,t.tensors[i].live=!1}n.x-=20,n.live=!1}var z=0,q=0,D=0,I=0;const X=10;var j=-1,F=-1,G=0,N=0,H=0,W=0,Y=[];Y.push(new class{constructor(){this.tensors=[],this.operators=[],this.input_tensors=[],this.param_tensors=[],this.output_tensors=[],this.truth_tensors=[],this.loss=null}add_tensor(t){this.tensors.push(t)}add_operator(t){var e=t.clone();this.operators.push(e);for(let t=0;t<e.inputs.length;t++)this.tensors[e.inputs[t]].input_to.push(this.operators.length-1);for(let t=0;t<e.outputs.length;t++)this.tensors[e.outputs[t]].output_of=this.operators.length-1}update_tensors(){for(let t=0;t<this.tensors.length;t++)this.tensors[t].input_to=[],this.tensors[t].output_of=null;for(let t=0;t<this.operators.length;t++){for(let e=0;e<this.operators[t].inputs.length;e++)this.tensors[this.operators[t].inputs[e]].input_to.push(t);for(let e=0;e<this.operators[t].outputs.length;e++)this.tensors[this.operators[t].outputs[e]].output_of=t}}expand(){for(let u=0;u<this.operators.length;u++)if(0==this.operators[u].func&&this.operators[u].network){var t=this.operators[u].network;t.expand();var e=this.operators[u],n=this.operators.length;this.operators[u]=t.operators[0];for(let e=1;e<t.operators.length;e++)this.add_operator(t.operators[e]);for(let a=0;a<t.tensors.length;a++){var s=a;if(t.input_tensors.includes(a)){var o=t.input_tensors.indexOf(a);s=e.inputs[o]}else if(t.output_tensors.includes(a)){o=t.output_tensors.indexOf(a);s=e.outputs[o]}else this.add_tensor(t.tensors[a]),s=this.tensors.length-1;for(let e=0;e<t.tensors[a].input_to.length;e++){var r=t.tensors[a].input_to[e],i=t.operators[r].inputs.indexOf(a);0==r?this.operators[u].inputs[i]=s:this.operators[r+n-1].inputs[i]=s}if(t.tensors[a].output_of||0==t.tensors[a].output_of){r=t.tensors[a].output_of,i=t.operators[r].outputs.indexOf(a);0==r?this.operators[u].outputs[i]=s:this.operators[r+n-1].outputs[i]=s}}this.update_tensors()}}to_string(){var t="";t+="Tensors: \n";for(let e=0;e<this.tensors.length;e++){t+="\t"+e+":\n",this.tensors[e].form&&(t+="\t\tform: "+String(this.tensors[e].form)+"\n"),t+="\t\tinput_to:\n";for(let n=0;n<this.tensors[e].input_to.length;n++)t+="\t\t\t"+this.tensors[e].input_to[n]+"\n";t+="\t\toutput_of\n",t+="\t\t\t"+this.tensors[e].output_of+"\n"}t+="Operators: \n";for(let e=0;e<this.operators.length;e++){t+="\t"+e+":\n",t+="\t\tinputs:\n";for(let n=0;n<this.operators[e].inputs.length;n++)t+="\t\t\t"+this.operators[e].inputs[n]+"\n";t+="\t\toutputs:\n";for(let n=0;n<this.operators[e].outputs.length;n++)t+="\t\t\t"+this.operators[e].outputs[n]+"\n";t+="\t\tfunc: "+this.operators[e].func+"\n"}t+="input_tensors:\n";for(let e=0;e<this.input_tensors.length;e++)t+="\t"+this.input_tensors[e]+"\n";t+="param_tensors:\n";for(let e=0;e<this.param_tensors.length;e++)t+="\t"+this.param_tensors[e]+"\n";t+="output_tensors:\n";for(let e=0;e<this.output_tensors.length;e++)t+="\t"+this.output_tensors[e]+"\n";return t}}),Y[0].add_tensor(new M(!1)),Y[0].tensors[0].x=200,Y[0].tensors[0].y=200,Y[0].add_tensor(new M(!1)),Y[0].tensors[1].x=100,Y[0].tensors[1].y=200,Y[0].add_tensor(new M(!1)),Y[0].tensors[2].x=150,Y[0].tensors[2].y=150;let J=new P;J.inputs=[1,2],J.outputs=[0],J.func=5,Y[0].add_operator(J),Y[0].add_tensor(new M(!0)),Y[0].tensors[3].x=400,Y[0].tensors[3].y=200,Y[0].add_tensor(new M(!0)),Y[0].tensors[4].x=300,Y[0].tensors[4].y=200,Y[0].add_tensor(new M(!1)),Y[0].tensors[5].x=350,Y[0].tensors[5].y=150,Y[0].add_tensor(new M(!0)),Y[0].tensors[6].x=350,Y[0].tensors[6].y=350;let K=new P;K.inputs=[4,5],K.outputs=[3],K.func=2,Y[0].add_operator(K),Y[0].add_tensor(new M(!0)),Y[0].tensors[7].x=500,Y[0].tensors[7].y=200,Y[0].add_tensor(new M(!0)),Y[0].tensors[8].x=400,Y[0].tensors[8].y=200,Y[0].add_tensor(new M(!0)),Y[0].tensors[9].x=450,Y[0].tensors[9].y=150,Y[0].add_tensor(new M(!0)),Y[0].tensors[10].x=450,Y[0].tensors[10].y=350;let Q=new P;Q.inputs=[8,9],Q.outputs=[7],Q.func=5,Y[0].add_operator(Q),Y[0].add_tensor(new M(!0)),Y[0].tensors[11].x=400,Y[0].tensors[11].y=400;let V=new P;function Z(t,e){let n=t.tensors[e];n.live?(q.fillStyle="white",q.lineWidth=1,q.setLineDash([]),q.strokeStyle="black"):(q.fillStyle="rgba(255,255,255,0)",q.lineWidth=1,q.setLineDash([3,4]),q.strokeStyle="Grey"),q.beginPath(),n.scalar?q.rect(n.x-5,n.y-5,10,10):q.rect(n.x-X,n.y-X,20,20),q.fill(),q.stroke()}function tt(t,e){let n,s,o,r=t.operators[e],i=q.createLinearGradient(0,0,D,I);switch(i.addColorStop(0,"#DE7521"),i.addColorStop(1,"#218ADE"),q.fillStyle=i,r.func){case 0:case 1:case 4:case 6:case 8:case 9:case 10:case 11:break;case 2:n=t.tensors[r.inputs[0]],s=t.tensors[r.inputs[1]],o=t.tensors[r.outputs[0]],q.beginPath(),q.moveTo(o.x-X,o.y-X),q.lineTo(o.x-X,o.y+X),q.lineTo(n.x+X,n.y+X),q.lineTo(n.x+X,n.y-X),q.closePath(),q.fill(),q.beginPath(),q.moveTo(o.x-X,o.y-X),q.lineTo(o.x-X,o.y+X),q.lineTo(s.x+X,s.y+X),q.lineTo(s.x+X,s.y-X),q.closePath(),q.fill();break;case 3:n=t.tensors[r.inputs[0]],s=t.tensors[r.inputs[1]],o=t.tensors[r.outputs[0]];break;case 5:n=t.tensors[r.inputs[0]],s=t.tensors[r.inputs[1]],o=t.tensors[r.outputs[0]],q.beginPath(),q.moveTo(o.x-X,o.y-X),q.lineTo(o.x-X,o.y+X),q.lineTo(n.x+X,n.y+X),q.lineTo(n.x+X,n.y-X),q.lineTo(s.x-X,s.y+X),q.lineTo(s.x+X,s.y+X),q.closePath(),q.fill();break;case 7:let e=t.tensors[r.inputs[0]];o=t.tensors[r.outputs[0]],q.beginPath(),q.moveTo(o.x-X,o.y-5),q.lineTo(o.x-X,o.y+5),q.lineTo(e.x+X,e.y+X),q.lineTo(e.x+X,e.y-X),q.closePath(),q.fill();break;default:console.log("Invalid operator types")}}function et(){z.width=z.getBoundingClientRect().width,z.height=z.getBoundingClientRect().height,D=z.width,I=z.height;var t=H-G,e=W-N;G=H,N=W;for(let t=0;t<Y[0].tensors.length;t++)Z(Y[0],t);for(let t=0;t<Y[0].operators.length;t++)tt(Y[0],t);if(-1!=j&&O(Y[0],j,t,e),-1!=F){var n=Y[0].operators[F];for(let s=0;s<n.inputs.length;s++)O(Y[0],n.inputs[s],t,e);for(let s=0;s<n.outputs.length;s++)O(Y[0],n.outputs[s],t,e)}window.requestAnimationFrame(et)}function nt(t){let e=B(Y[0],H,W);console.log("Clicked Indices ",e);for(let t=0;t<e.length;t++){var n=e[t],s=Y[0].tensors[n];null==s.output_of||0==s.input_to.length?s.live=!s.live:(console.log("Unmerge"),U(Y[0],n))}}function st(t){j=-1,F=-1;let e=B(Y[0],H,W);e.length>=2&&function(t,e,n){if(t.tensors[e].live&&t.tensors[n].live)return void console.log("Both merged tensors are live, so don't do anything.");let s=t.tensors[e],o=t.tensors[n],r=n,i=e;if(null!=s.output_of&&null==o.output_of);else{if(null==o.output_of||null!=s.output_of)return void console.log("Error merging, only one input must have an output");var u=o;o=s,s=u,r=e,i=n}if(console.log(s.output_of,o.input_to),s.output_of==o.input_to)return void console.log("Error merging, these are input and output of the same function");let a=t.operators[o.input_to].inputs.indexOf(r);t.operators[o.input_to].inputs[a]=i,s.input_to=o.input_to,s.live=!0,function(t,e){for(let n=0;n<t.operators.length;n++){for(let s=0;s<t.operators[n].inputs.length;s++)t.operators[n].inputs[s]>e&&(t.operators[n].inputs[s]-=1);for(let s=0;s<t.operators[n].outputs.length;s++)t.operators[n].outputs[s]>e&&(t.operators[n].outputs[s]-=1)}t.tensors.splice(e,1)}(t,r)}(Y[0],e[0],e[1])}function ot(t){let e=B(Y[0],H,W);0!=e.length&&(j=e[0]);let n=function(t,e,n){var s=[];for(let p=0;p<t.operators.length;p++){var o=t.operators[p],r=1e6,i=-1e6,u=1e6,a=-1e6;for(let e=0;e<o.inputs.length;e++){var l=t.tensors[o.inputs[e]];r=Math.min(l.x+A,r),i=Math.max(l.x-A,i),u=Math.min(l.y+A,u),a=Math.max(l.y+A,a)}for(let e=0;e<o.outputs.length;e++)l=t.tensors[o.outputs[e]],r=Math.min(l.x+A,r),i=Math.max(l.x-A,i),u=Math.min(l.y+A,u),a=Math.max(l.y+A,a);r<e&&i>e&&u<n&&a>n&&s.push(p)}return s}(Y[0],H,W);0!=n.length&&(F=n[0])}function rt(t){t.offsetX?(H=t.offsetX,W=t.offsetY):t.layerX&&(H=t.layerX,W=t.layerY)}function it(e){let n,s,o,r,c,f,d,g,_,m,y,v;return{c(){n=a("main"),s=a("div"),o=a("h1"),r=l("Hello "),c=l(e[0]),f=l("!"),d=p(),g=a("button"),g.textContent="Get a random number",_=p(),m=a("div"),m.innerHTML='<div id="left_tool_bar" class="svelte-p9adry"><div id="left_tool_bar_header" class="svelte-p9adry">header</div> \n\t\t\t<div id="left_tool_bar_add_operator" class="svelte-p9adry">add operator</div> \n\t\t\t<div id="left_tool_bar_footer" class="svelte-p9adry">footer</div></div> \n\t\t<div id="canvas_container" class="svelte-p9adry"><canvas id="gui_canvas" class="svelte-p9adry"></canvas></div>',h(o,"class","svelte-p9adry"),h(s,"id","examplestuff"),h(s,"class","svelte-p9adry"),h(m,"id","workspace"),h(m,"class","svelte-p9adry"),h(n,"class","svelte-p9adry")},m(t,u){var a,l,p,h;!function(t,e,n){t.insertBefore(e,n||null)}(t,n,u),i(n,s),i(s,o),i(o,r),i(o,c),i(o,f),i(s,d),i(s,g),i(n,_),i(n,m),y||(a=g,l="click",p=e[1],a.addEventListener(l,p,h),v=()=>a.removeEventListener(l,p,h),y=!0)},p(t,[e]){1&e&&function(t,e){e=""+e,t.wholeText!==e&&(t.data=e)}(c,t[0])},i:t,o:t,d(t){t&&u(n),y=!1,v()}}}function ut(t,e,n){d((()=>{(z=document.getElementById("gui_canvas")).addEventListener("mousedown",ot,!1),z.addEventListener("mousemove",rt,!1),z.addEventListener("mouseup",st,!1),z.addEventListener("dblclick",nt,!1),q=z.getContext("2d"),z.width=z.getBoundingClientRect().width,z.height=z.getBoundingClientRect().height,D=z.width,I=z.height,window.requestAnimationFrame(et)}));let s=-3;return[s,function(){fetch("../rand").then((t=>t.text())).then((t=>n(0,s=t)))}]}V.inputs=[6],V.outputs=[10],V.func=7,Y[0].add_operator(V);return new class extends class{$destroy(){!function(t,e){const n=t.$$;null!==n.fragment&&(s(n.on_destroy),n.fragment&&n.fragment.d(e),n.on_destroy=n.fragment=null,n.ctx=[])}(this,1),this.$destroy=t}$on(t,e){const n=this.$$.callbacks[t]||(this.$$.callbacks[t]=[]);return n.push(e),()=>{const t=n.indexOf(e);-1!==t&&n.splice(t,1)}}$set(t){var e;this.$$set&&(e=t,0!==Object.keys(e).length)&&(this.$$.skip_bound=!0,this.$$set(t),this.$$.skip_bound=!1)}}{constructor(t){super(),C(this,t,ut,it,r,{})}}({target:document.body,props:{name:"world"}})}();
//# sourceMappingURL=bundle.js.map
