var app=function(){"use strict";function t(){}function e(t){return t()}function n(){return Object.create(null)}function o(t){t.forEach(e)}function s(t){return"function"==typeof t}function r(t,e){return t!=t?e==e:t!==e||t&&"object"==typeof t||"function"==typeof t}function i(t,e){t.appendChild(e)}function u(t){t.parentNode.removeChild(t)}function a(t){return document.createElement(t)}function l(t){return document.createTextNode(t)}function p(){return l(" ")}function h(t,e,n){null==n?t.removeAttribute(e):t.getAttribute(e)!==n&&t.setAttribute(e,n)}let c;function f(t){c=t}function d(t){(function(){if(!c)throw new Error("Function called outside component initialization");return c})().$$.on_mount.push(t)}const g=[],_=[],m=[],y=[],v=Promise.resolve();let x=!1;function w(t){m.push(t)}const b=new Set;let $=0;function k(){const t=c;do{for(;$<g.length;){const t=g[$];$++,f(t),T(t.$$)}for(f(null),g.length=0,$=0;_.length;)_.pop()();for(let t=0;t<m.length;t+=1){const e=m[t];b.has(e)||(b.add(e),e())}m.length=0}while(g.length);for(;y.length;)y.pop()();x=!1,b.clear(),f(t)}function T(t){if(null!==t.fragment){t.update(),o(t.before_update);const e=t.dirty;t.dirty=[-1],t.fragment&&t.fragment.p(t.ctx,e),t.after_update.forEach(w)}}const L=new Set;function E(t,e){-1===t.$$.dirty[0]&&(g.push(t),x||(x=!0,v.then(k)),t.$$.dirty.fill(0)),t.$$.dirty[e/31|0]|=1<<e%31}function C(r,i,a,l,p,h,d,g=[-1]){const _=c;f(r);const m=r.$$={fragment:null,ctx:null,props:h,update:t,not_equal:p,bound:n(),on_mount:[],on_destroy:[],on_disconnect:[],before_update:[],after_update:[],context:new Map(i.context||(_?_.$$.context:[])),callbacks:n(),dirty:g,skip_bound:!1,root:i.target||_.$$.root};d&&d(m.root);let y=!1;if(m.ctx=a?a(r,i.props||{},((t,e,...n)=>{const o=n.length?n[0]:e;return m.ctx&&p(m.ctx[t],m.ctx[t]=o)&&(!m.skip_bound&&m.bound[t]&&m.bound[t](o),y&&E(r,t)),e})):[],m.update(),y=!0,o(m.before_update),m.fragment=!!l&&l(m.ctx),i.target){if(i.hydrate){const t=function(t){return Array.from(t.childNodes)}(i.target);m.fragment&&m.fragment.l(t),t.forEach(u)}else m.fragment&&m.fragment.c();i.intro&&((v=r.$$.fragment)&&v.i&&(L.delete(v),v.i(x))),function(t,n,r,i){const{fragment:u,on_mount:a,on_destroy:l,after_update:p}=t.$$;u&&u.m(n,r),i||w((()=>{const n=a.map(e).filter(s);l?l.push(...n):o(n),t.$$.on_mount=[]})),p.forEach(w)}(r,i.target,i.anchor,i.customElement),k()}var v,x;f(_)}class M{constructor(t,e){this.scalar=!1,this.live=t||!1,e?this.form=e:e=[],this.x=0,this.y=0,this.input_to=[],this.output_of=null}calc_size(){if(this.form){var t=1;for(let e=0;e<this.form.length;e++)t*=this.form[e];this.size=t}else this.size=0;return this.size}}class P{constructor(t){this.inputs=[],this.outputs=[],this.func=t,this.size=null,this.network=null}clone(){var t=new P(this.func);return t.inputs=[...this.inputs],t.outputs=[...this.outputs],t.network=this.network,t}}class R{constructor(t,e){this.name=t,this.num_inputs=e}calc_form(t,e){var n=[];switch(console.log(this.name),this.name){case"identity":case"add":case"subtract":case"scale":case"softmax":case"hardmax":case"ReLU":case"LeakyReLU":case"Leaky to ReLU":n.push(e.tensors[t[0]].form);break;case"full":var o=e.tensors[t[0]].form,s=e.tensors[t[1]].form,r=1;for(let t=0;t<o.length;t++)r*=o[t];var i=1;for(let t=0;t<s.length;t++)i*=s[t];(u=[]).push(i/r),n.push(u);break;case"amass":case"max":(u=[]).push(1),n.push(u);break;case"convolution":o=e.tensors[t[0]].form,s=e.tensors[t[1]].form;var u=[];for(let t=0;t<o.length;t++)s.length<=t?u.push(o[t]):u.push(o[t]-s[t]+1);n.push(u);break;case"squared dist":n.push([1])}return n}}var S=Array.apply(null,Array(12)).map((function(){}));S[0]=new R("abstraction",0),S[1]=new R("identity",1),S[2]=new R("add",2),S[3]=new R("subtract",2),S[4]=new R("scale",2),S[5]=new R("full",2),S[6]=new R("amass",1),S[7]=new R("softmax",1),S[8]=new R("hardmax",1),S[9]=new R("max",1),S[10]=new R("convolution",2),S[11]=new R("squared dist",2),S[12]=new R("ReLU",1),S[13]=new R("LeakyReLU",1),S[14]=new R("Leaky to ReLU",1);var A=0,O=0,B=0,U=0;const z=10;var q=-1,D=-1,F=0,I=0,X=0,j=0,G=[];G.push(new class{constructor(){this.tensors=[],this.operators=[],this.input_tensors=[],this.param_tensors=[],this.output_tensors=[],this.truth_tensors=[],this.loss=null}add_tensor(t){this.tensors.push(t)}add_operator(t){var e=t.clone();this.operators.push(e);for(let t=0;t<e.inputs.length;t++)this.tensors[e.inputs[t]].input_to.push(this.operators.length-1);for(let t=0;t<e.outputs.length;t++)this.tensors[e.outputs[t]].output_of=this.operators.length-1}update_tensors(){for(let t=0;t<this.tensors.length;t++)this.tensors[t].input_to=[],this.tensors[t].output_of=null;for(let t=0;t<this.operators.length;t++){for(let e=0;e<this.operators[t].inputs.length;e++)this.tensors[this.operators[t].inputs[e]].input_to.push(t);for(let e=0;e<this.operators[t].outputs.length;e++)this.tensors[this.operators[t].outputs[e]].output_of=t}}expand(){for(let u=0;u<this.operators.length;u++)if(0==this.operators[u].func&&this.operators[u].network){var t=this.operators[u].network;t.expand();var e=this.operators[u],n=this.operators.length;this.operators[u]=t.operators[0];for(let e=1;e<t.operators.length;e++)this.add_operator(t.operators[e]);for(let a=0;a<t.tensors.length;a++){var o=a;if(t.input_tensors.includes(a)){var s=t.input_tensors.indexOf(a);o=e.inputs[s]}else if(t.output_tensors.includes(a)){s=t.output_tensors.indexOf(a);o=e.outputs[s]}else this.add_tensor(t.tensors[a]),o=this.tensors.length-1;for(let e=0;e<t.tensors[a].input_to.length;e++){var r=t.tensors[a].input_to[e],i=t.operators[r].inputs.indexOf(a);0==r?this.operators[u].inputs[i]=o:this.operators[r+n-1].inputs[i]=o}if(t.tensors[a].output_of||0==t.tensors[a].output_of){r=t.tensors[a].output_of,i=t.operators[r].outputs.indexOf(a);0==r?this.operators[u].outputs[i]=o:this.operators[r+n-1].outputs[i]=o}}this.update_tensors()}}to_string(){var t="";t+="Tensors: \n";for(let e=0;e<this.tensors.length;e++){t+="\t"+e+":\n",this.tensors[e].form&&(t+="\t\tform: "+String(this.tensors[e].form)+"\n"),t+="\t\tinput_to:\n";for(let n=0;n<this.tensors[e].input_to.length;n++)t+="\t\t\t"+this.tensors[e].input_to[n]+"\n";t+="\t\toutput_of\n",t+="\t\t\t"+this.tensors[e].output_of+"\n"}t+="Operators: \n";for(let e=0;e<this.operators.length;e++){t+="\t"+e+":\n",t+="\t\tinputs:\n";for(let n=0;n<this.operators[e].inputs.length;n++)t+="\t\t\t"+this.operators[e].inputs[n]+"\n";t+="\t\toutputs:\n";for(let n=0;n<this.operators[e].outputs.length;n++)t+="\t\t\t"+this.operators[e].outputs[n]+"\n";t+="\t\tfunc: "+this.operators[e].func+"\n"}t+="input_tensors:\n";for(let e=0;e<this.input_tensors.length;e++)t+="\t"+this.input_tensors[e]+"\n";t+="param_tensors:\n";for(let e=0;e<this.param_tensors.length;e++)t+="\t"+this.param_tensors[e]+"\n";t+="output_tensors:\n";for(let e=0;e<this.output_tensors.length;e++)t+="\t"+this.output_tensors[e]+"\n";return t}}),G[0].add_tensor(new M(!1)),G[0].tensors[0].x=200,G[0].tensors[0].y=200,G[0].add_tensor(new M(!1)),G[0].tensors[1].x=100,G[0].tensors[1].y=200,G[0].add_tensor(new M(!1)),G[0].tensors[2].x=150,G[0].tensors[2].y=150;let N=new P;N.inputs=[1,2],N.outputs=[0],N.func=5,G[0].add_operator(N),G[0].add_tensor(new M(!0)),G[0].tensors[3].x=400,G[0].tensors[3].y=200,G[0].add_tensor(new M(!0)),G[0].tensors[4].x=300,G[0].tensors[4].y=200,G[0].add_tensor(new M(!1)),G[0].tensors[5].x=350,G[0].tensors[5].y=150,G[0].add_tensor(new M(!0)),G[0].tensors[6].x=350,G[0].tensors[6].y=350;let H=new P;H.inputs=[4,5],H.outputs=[3],H.func=2,G[0].add_operator(H),G[0].add_tensor(new M(!0)),G[0].tensors[7].x=500,G[0].tensors[7].y=200,G[0].add_tensor(new M(!0)),G[0].tensors[8].x=400,G[0].tensors[8].y=200,G[0].add_tensor(new M(!0)),G[0].tensors[9].x=450,G[0].tensors[9].y=150,G[0].add_tensor(new M(!0)),G[0].tensors[10].x=450,G[0].tensors[10].y=350;let W=new P;W.inputs=[8,9],W.outputs=[7],W.func=5,G[0].add_operator(W),G[0].add_tensor(new M(!0)),G[0].tensors[11].x=400,G[0].tensors[11].y=400;let Y=new P;function J(t,e){let n=t.tensors[e];n.live?(O.fillStyle="white",O.lineWidth=1,O.setLineDash([]),O.strokeStyle="black"):(O.fillStyle="rgba(255,255,255,0)",O.lineWidth=1,O.setLineDash([3,4]),O.strokeStyle="Grey"),O.beginPath(),n.scalar?O.rect(n.x-5,n.y-5,10,10):O.rect(n.x-z,n.y-z,20,20),O.fill(),O.stroke()}function K(t,e){let n,o,s,r=t.operators[e],i=O.createLinearGradient(0,0,B,U);switch(i.addColorStop(0,"#DE7521"),i.addColorStop(1,"#218ADE"),O.fillStyle=i,r.func){case 0:case 1:case 4:case 6:case 8:case 9:case 10:case 11:break;case 2:n=t.tensors[r.inputs[0]],o=t.tensors[r.inputs[1]],s=t.tensors[r.outputs[0]],O.beginPath(),O.moveTo(s.x-z,s.y-z),O.lineTo(s.x-z,s.y+z),O.lineTo(n.x+z,n.y+z),O.lineTo(n.x+z,n.y-z),O.closePath(),O.fill(),O.beginPath(),O.moveTo(s.x-z,s.y-z),O.lineTo(s.x-z,s.y+z),O.lineTo(o.x+z,o.y+z),O.lineTo(o.x+z,o.y-z),O.closePath(),O.fill();break;case 3:n=t.tensors[r.inputs[0]],o=t.tensors[r.inputs[1]],s=t.tensors[r.outputs[0]];break;case 5:n=t.tensors[r.inputs[0]],o=t.tensors[r.inputs[1]],s=t.tensors[r.outputs[0]],O.beginPath(),O.moveTo(s.x-z,s.y-z),O.lineTo(s.x-z,s.y+z),O.lineTo(n.x+z,n.y+z),O.lineTo(n.x+z,n.y-z),O.lineTo(o.x-z,o.y+z),O.lineTo(o.x+z,o.y+z),O.closePath(),O.fill();break;case 7:let e=t.tensors[r.inputs[0]];s=t.tensors[r.outputs[0]],O.beginPath(),O.moveTo(s.x-z,s.y-5),O.lineTo(s.x-z,s.y+5),O.lineTo(e.x+z,e.y+z),O.lineTo(e.x+z,e.y-z),O.closePath(),O.fill();break;default:console.log("Invalid operator types")}}function Q(){A.width=A.getBoundingClientRect().width,A.height=A.getBoundingClientRect().height,B=A.width,U=A.height;var t=X-F,e=j-I;F=X,I=j;for(let t=0;t<G[0].tensors.length;t++)J(G[0],t);for(let t=0;t<G[0].operators.length;t++)K(G[0],t);if(-1!=q&&V(q,t,e),-1!=D){var n=G[0].operators[D];for(let o=0;o<n.inputs.length;o++)V(n.inputs[o],t,e);for(let o=0;o<n.outputs.length;o++)V(n.outputs[o],t,e)}window.requestAnimationFrame(Q)}function V(t,e,n){G[0].tensors[t].x+=e,G[0].tensors[t].y+=n}function Z(){var t=[];for(let e=0;e<G.length;e++)for(let n=0;n<G[0].tensors.length;n++)G[e].tensors[n].x-z<X&&G[e].tensors[n].x+z>X&&G[e].tensors[n].y-z<j&&G[e].tensors[n].y+z>j&&t.push(n);return t}function tt(t){var e=G[0].tensors[t],n=e.input_to;e.input_to=[],console.log("Functions ",n);for(let u=0;u<n.length;u++){var o=n[u],s=G[0].operators[o],r=G[0].tensors.length;G[0].add_tensor(new M(!0));var i=s.inputs.findIndex((e=>e==t));s.inputs[i]=r,G[0].tensors[r].x=e.x+20,G[0].tensors[r].y=e.y,G[0].tensors[r].input_to=[o],G[0].tensors[r].output_of=null,G[0].tensors[r].live=!1}e.x-=20,e.live=!1}function et(t,e){if(G[0].tensors[t].live&&G[0].tensors[e].live)return void console.log("Both merged tensors are live, so don't do anything.");let n=G[0].tensors[t],o=G[0].tensors[e],s=e,r=t;if(null!=n.output_of&&null==o.output_of);else{if(null==o.output_of||null!=n.output_of)return void console.log("Error merging, only one input must have an output");var i=o;o=n,n=i,s=t,r=e}if(console.log(n.output_of,o.input_to),n.output_of==o.input_to)return void console.log("Error merging, these are input and output of the same function");let u=G[0].operators[o.input_to].inputs.indexOf(s);G[0].operators[o.input_to].inputs[u]=r,n.input_to=o.input_to,n.live=!0,function(t){for(let e=0;e<G[0].operators.length;e++){for(let n=0;n<G[0].operators[e].inputs.length;n++)G[0].operators[e].inputs[n]>t&&(G[0].operators[e].inputs[n]-=1);for(let n=0;n<G[0].operators[e].outputs.length;n++)G[0].operators[e].outputs[n]>t&&(G[0].operators[e].outputs[n]-=1)}G[0].tensors.splice(t,1)}(s)}function nt(t){let e=Z();console.log("Clicked Indices ",e);for(let t=0;t<e.length;t++){var n=e[t],o=G[0].tensors[n];null==o.output_of||0==o.input_to.length?o.live=!o.live:(console.log("Unmerge"),tt(n))}}function ot(t){q=-1,D=-1;let e=Z();e.length>=2&&et(e[0],e[1])}function st(t){let e=Z();0!=e.length&&(q=e[0]);let n=function(){var t=[];for(let u=0;u<G[0].operators.length;u++){var e=G[0].operators[u],n=B,o=0,s=U,r=0;for(let t=0;t<e.inputs.length;t++){var i=G[0].tensors[e.inputs[t]];n=Math.min(i.x+z,n),o=Math.max(i.x-z,o),s=Math.min(i.y+z,s),r=Math.max(i.y+z,r)}for(let t=0;t<e.outputs.length;t++)i=G[0].tensors[e.outputs[t]],n=Math.min(i.x+z,n),o=Math.max(i.x-z,o),s=Math.min(i.y+z,s),r=Math.max(i.y+z,r);n<X&&o>X&&s<j&&r>j&&t.push(u)}return t}();0!=n.length&&(D=n[0])}function rt(t){t.offsetX?(X=t.offsetX,j=t.offsetY):t.layerX&&(X=t.layerX,j=t.layerY)}function it(e){let n,o,s,r,c,f,d,g,_,m,y,v;return{c(){n=a("main"),o=a("div"),s=a("h1"),r=l("Hello "),c=l(e[0]),f=l("!"),d=p(),g=a("button"),g.textContent="Get a random number",_=p(),m=a("div"),m.innerHTML='<div id="left_tool_bar" class="svelte-p9adry"><div id="left_tool_bar_header" class="svelte-p9adry">header</div> \n\t\t\t<div id="left_tool_bar_add_operator" class="svelte-p9adry">add operator</div> \n\t\t\t<div id="left_tool_bar_footer" class="svelte-p9adry">footer</div></div> \n\t\t<div id="canvas_container" class="svelte-p9adry"><canvas id="gui_canvas" class="svelte-p9adry"></canvas></div>',h(s,"class","svelte-p9adry"),h(o,"id","examplestuff"),h(o,"class","svelte-p9adry"),h(m,"id","workspace"),h(m,"class","svelte-p9adry"),h(n,"class","svelte-p9adry")},m(t,u){var a,l,p,h;!function(t,e,n){t.insertBefore(e,n||null)}(t,n,u),i(n,o),i(o,s),i(s,r),i(s,c),i(s,f),i(o,d),i(o,g),i(n,_),i(n,m),y||(a=g,l="click",p=e[1],a.addEventListener(l,p,h),v=()=>a.removeEventListener(l,p,h),y=!0)},p(t,[e]){1&e&&function(t,e){e=""+e,t.wholeText!==e&&(t.data=e)}(c,t[0])},i:t,o:t,d(t){t&&u(n),y=!1,v()}}}function ut(t,e,n){d((()=>{(A=document.getElementById("gui_canvas")).addEventListener("mousedown",st,!1),A.addEventListener("mousemove",rt,!1),A.addEventListener("mouseup",ot,!1),A.addEventListener("dblclick",nt,!1),O=A.getContext("2d"),A.width=A.getBoundingClientRect().width,A.height=A.getBoundingClientRect().height,B=A.width,U=A.height,window.requestAnimationFrame(Q)}));let o=-3;return[o,function(){fetch("../rand").then((t=>t.text())).then((t=>n(0,o=t)))}]}Y.inputs=[6],Y.outputs=[10],Y.func=7,G[0].add_operator(Y);return new class extends class{$destroy(){!function(t,e){const n=t.$$;null!==n.fragment&&(o(n.on_destroy),n.fragment&&n.fragment.d(e),n.on_destroy=n.fragment=null,n.ctx=[])}(this,1),this.$destroy=t}$on(t,e){const n=this.$$.callbacks[t]||(this.$$.callbacks[t]=[]);return n.push(e),()=>{const t=n.indexOf(e);-1!==t&&n.splice(t,1)}}$set(t){var e;this.$$set&&(e=t,0!==Object.keys(e).length)&&(this.$$.skip_bound=!0,this.$$set(t),this.$$.skip_bound=!1)}}{constructor(t){super(),C(this,t,ut,it,r,{})}}({target:document.body,props:{name:"world"}})}();
//# sourceMappingURL=bundle.js.map
